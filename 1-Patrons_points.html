<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />


<meta name="author" content="Philippe Marchand, Université du Québec en Abitibi-Témiscamingue" />


<title>Statistiques spatiales en écologie, Partie 1</title>

<script src="libs/jquery-1.11.3/jquery.min.js"></script>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link href="libs/bootstrap-3.3.5/css/united.min.css" rel="stylesheet" />
<script src="libs/bootstrap-3.3.5/js/bootstrap.min.js"></script>
<script src="libs/bootstrap-3.3.5/shim/html5shiv.min.js"></script>
<script src="libs/bootstrap-3.3.5/shim/respond.min.js"></script>
<script src="libs/jqueryui-1.11.4/jquery-ui.min.js"></script>
<link href="libs/tocify-1.9.1/jquery.tocify.css" rel="stylesheet" />
<script src="libs/tocify-1.9.1/jquery.tocify.js"></script>
<script src="libs/navigation-1.1/tabsets.js"></script>
<link href="libs/highlightjs-9.12.0/default.css" rel="stylesheet" />
<script src="libs/highlightjs-9.12.0/highlight.js"></script>

<style type="text/css">code{white-space: pre;}</style>
<style type="text/css">
  pre:not([class]) {
    background-color: white;
  }
</style>
<script type="text/javascript">
if (window.hljs) {
  hljs.configure({languages: []});
  hljs.initHighlightingOnLoad();
  if (document.readyState && document.readyState === "complete") {
    window.setTimeout(function() { hljs.initHighlighting(); }, 0);
  }
}
</script>



<style type="text/css">
h1 {
  font-size: 34px;
}
h1.title {
  font-size: 38px;
}
h2 {
  font-size: 30px;
}
h3 {
  font-size: 24px;
}
h4 {
  font-size: 18px;
}
h5 {
  font-size: 16px;
}
h6 {
  font-size: 12px;
}
.table th:not([align]) {
  text-align: left;
}
</style>




<style type = "text/css">
.main-container {
  max-width: 940px;
  margin-left: auto;
  margin-right: auto;
}
code {
  color: inherit;
  background-color: rgba(0, 0, 0, 0.04);
}
img {
  max-width:100%;
}
.tabbed-pane {
  padding-top: 12px;
}
.html-widget {
  margin-bottom: 20px;
}
button.code-folding-btn:focus {
  outline: none;
}
summary {
  display: list-item;
}
</style>



<!-- tabsets -->

<style type="text/css">
.tabset-dropdown > .nav-tabs {
  display: inline-table;
  max-height: 500px;
  min-height: 44px;
  overflow-y: auto;
  background: white;
  border: 1px solid #ddd;
  border-radius: 4px;
}

.tabset-dropdown > .nav-tabs > li.active:before {
  content: "";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li.active:before {
  content: "&#xe258;";
  border: none;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open:before {
  content: "";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs > li.active {
  display: block;
}

.tabset-dropdown > .nav-tabs > li > a,
.tabset-dropdown > .nav-tabs > li > a:focus,
.tabset-dropdown > .nav-tabs > li > a:hover {
  border: none;
  display: inline-block;
  border-radius: 4px;
  background-color: transparent;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li {
  display: block;
  float: none;
}

.tabset-dropdown > .nav-tabs > li {
  display: none;
}
</style>

<!-- code folding -->



<style type="text/css">

#TOC {
  margin: 25px 0px 20px 0px;
}
@media (max-width: 768px) {
#TOC {
  position: relative;
  width: 100%;
}
}

@media print {
.toc-content {
  /* see https://github.com/w3c/csswg-drafts/issues/4434 */
  float: right;
}
}

.toc-content {
  padding-left: 30px;
  padding-right: 40px;
}

div.main-container {
  max-width: 1200px;
}

div.tocify {
  width: 20%;
  max-width: 260px;
  max-height: 85%;
}

@media (min-width: 768px) and (max-width: 991px) {
  div.tocify {
    width: 25%;
  }
}

@media (max-width: 767px) {
  div.tocify {
    width: 100%;
    max-width: none;
  }
}

.tocify ul, .tocify li {
  line-height: 20px;
}

.tocify-subheader .tocify-item {
  font-size: 0.90em;
}

.tocify .list-group-item {
  border-radius: 0px;
}


</style>



</head>

<body>


<div class="container-fluid main-container">


<!-- setup 3col/9col grid for toc_float and main content  -->
<div class="row-fluid">
<div class="col-xs-12 col-sm-4 col-md-3">
<div id="TOC" class="tocify">
</div>
</div>

<div class="toc-content col-xs-12 col-sm-8 col-md-9">




<div class="fluid-row" id="header">



<h1 class="title toc-ignore">Statistiques spatiales en écologie, Partie 1</h1>
<h4 class="author">Philippe Marchand, Université du Québec en Abitibi-Témiscamingue</h4>
<h4 class="date">12 janvier 2021</h4>

</div>


<div id="introduction-aux-statistiques-spatiales" class="section level1">
<h1>Introduction aux statistiques spatiales</h1>
<div id="types-danalyses-spatiales" class="section level2">
<h2>Types d’analyses spatiales</h2>
<p>Dans le cadre de cette formation, nous discuterons de trois types d’analyses spatiales: l’analyse des patrons de points, les modèles géostatistiques et les modèles de données aréales.</p>
<p>Dans l’<strong>analyse des patrons de points</strong>, nous avons des données ponctuelles représentant la position d’individus ou d’événements dans une région d’étude et nous supposons que tous les individus ou événements ont été recensés dans cette région. Cette analyse s’intéresse à la distribution des positions des points eux-mêmes. Voici quelques questions typiques de l’analyse des patrons de points:</p>
<ul>
<li><p>Les points sont-ils disposés aléatoirement ou agglomérés?</p></li>
<li><p>Deux types de points sont-ils disposés indépendamment?</p></li>
</ul>
<p>Les <strong>modèles géostatistiques</strong> visent à représenter la distribution spatiale de variables continues qui sont mesurés à certains points d’échantillonnage. Ils supposent que les mesures de ces variables à différents points sont corrélées en fonction de la distance entre ces points. Parmi les applications des modèles géostatistiques, notons le lissage des données spatiales (ex.: produire une carte d’une variable sur l’ensemble d’une région en fonction des mesures ponctuelles) et la prédiction de ces variables pour des points non-échantillonnés.</p>
<p>Les <strong>données aréales</strong> sont des mesures prises non pas à des points, mais pour des régions de l’espace représentées par des polygones (ex.: divisions du territoire, cellules d’une grille). Les modèles représentant ces types de données définissent un réseau de voisinage reliant les régions et incluent une corrélation spatiale entre régions voisines.</p>
</div>
<div id="stationnarité-et-isotropie" class="section level2">
<h2>Stationnarité et isotropie</h2>
<p>Plusieurs analyses spatiales supposent que les variables sont <strong>stationnaires</strong> dans l’espace. Comme pour la stationnarité dans le domaine temporel, cette propriété signifie que les statistiques sommaires (moyenne, variance et corrélations entre mesures d’une variable) ne varient pas avec une translation dans l’espace. Par exemple, la corrélation spatiale entre deux points peut dépendre de la distance les séparant, mais pas de leur position absolue.</p>
<p>En particulier, il ne peut pas y avoir de tendance à grande échelle (souvent appelée <em>gradient</em> dans un contexte spatial), ou bien cette tendance doit être prise en compte afin de modéliser la corrélation spatiale des résidus.</p>
<p>Dans le cas de l’analyse des patrons de points, la stationnarité (aussi appelée homogénéité dans ce contexte) signifie que la densité des points ne suit pas de tendance à grande échelle.</p>
<p>Dans un modèle statistique <strong>isotropique</strong>, les corrélations spatiales entre les mesures à deux points dépendent seulement de la distance entre ces points, pas de la direction. Dans ce cas, les statistiques sommaires ne varient pas si on effectue une rotation dans l’espace.</p>
</div>
<div id="données-géoréférencées" class="section level2">
<h2>Données géoréférencées</h2>
<p>Les études environnementales utilisent de plus en plus de données provenant de sources de données géospatiales, c’est-à-dire des variables mesurées sur une grande partie du globe (ex.: climat, télédétection). Le traitement de ces données requiert des concepts liés aux systèmes d’information géographique (SIG), qui ne sont pas couverts dans cet atelier, alors que nous nous concentrons sur les aspects statistiques de données variant dans l’espace.</p>
<p>L’utilisation de données géospatiales ne signifie pas nécessairement qu’il faut avoir recours à des statistiques spatiales. Par exemple, il est courant d’extraire les valeurs de ces variables géographiques à des points d’étude pour expliquer une réponse biologique observée sur le terrain. Dans ce cas, l’utilisation de statistiques spatiales est seulement nécessaire en présence d’une corrélation spatiale dans les résidus, après avoir tenu compte de l’effet des prédicteurs.</p>
</div>
</div>
<div id="analyse-des-patrons-de-points" class="section level1">
<h1>Analyse des patrons de points</h1>
<div id="patron-de-points-et-processus-ponctuel" class="section level2">
<h2>Patron de points et processus ponctuel</h2>
<p>Un patron de points (<em>point pattern</em>) décrit la position spatiale (le plus souvent en 2D) d’individus ou d’événements, représentés par des points, dans une aire d’étude donnée, souvent appelée la <em>fenêtre</em> d’observation.</p>
<p>On suppose que chaque point a une étendue spatiale négligeable par rapport aux distances entre les points. Des méthodes plus complexes existent pour traiter des patrons spatiaux d’objets qui ont une largeur non-néligeable, mais ce sujet dépasse la portée de cet atelier.</p>
<p>Un processus ponctuel (<em>point process</em>) est un modèle statistique qui peut être utilisé pour simuler des patrons de points ou expliquer un patron de points observé.</p>
</div>
<div id="structure-spatiale-totalement-aléatoire" class="section level2">
<h2>Structure spatiale totalement aléatoire</h2>
<p>Une structure spatiale totalement aléatoire (<em>complete spatial randomness</em>) est un des patrons les plus simples, qui sert de modèle nul pour évaluer les caractéristiques de patrons de points réels. Dans ce patron, la présence d’un point à une position donnée est indépendante de la présence de points dans un voisinage.</p>
<p>Le processus créant ce patron est un processus de Poisson homogène. Selon ce modèle, le nombre de points dans toute région de superficie <span class="math inline">\(A\)</span> suit une distribution de Poisson: <span class="math inline">\(N(A) \sim \text{Pois}(\lambda A)\)</span>, où <span class="math inline">\(\lambda\)</span> est l’<em>intensité</em> du processus (i.e. la densité de points). <span class="math inline">\(N\)</span> est indépendant entre deux régions disjointes, peu importe comment ces régions sont définies.</p>
<p>Dans le graphique ci-dessous, seul le patron à droite est totalement aléatoire. Le patron à gauche montre une agrégation des points (probabilité plus grande d’observer un point si on est à proximité d’un autre point), tandis que le patron du centre montre une répulsion (faible probabilité d’observer un point très près d’un autre).</p>
<p><img src="1-Patrons_points_files/figure-html/unnamed-chunk-2-1.png" width="864" /></p>
</div>
<div id="analyse-exploratoire-ou-inférentielle-pour-un-patron-de-points" class="section level2">
<h2>Analyse exploratoire ou inférentielle pour un patron de points</h2>
<p>Plusieurs statistiques sommaires sont utilisées pour décrire les caractéristiques un patron de points. La plus simple est l’<strong>intensité</strong> <span class="math inline">\(\lambda\)</span>, qui comme mentionné plus haut représente la densité de points par unité de surface. Si le patron de points est hétérogène, l’intensité n’est pas constante, mais dépend de la position: <span class="math inline">\(\lambda(x, y)\)</span>.</p>
<p>Par rapport à l’intensité qui est une statistique dite de premier ordre, les statistiques de second ordre décrivent comment la probabilité de présence d’un point dans une région dépend de la présence d’autres points. L’indice <span class="math inline">\(K\)</span> de Ripley présenté dans la prochaine section est un exemple de statistique sommaire de second ordre.</p>
<p>Les inférences statistiques réalisées sur des patrons de points consistent habituellement à tester l’hypothèse que le patron de points correspond à un modèle nul donné, par exemple une structure spatiale totalement aléatoire, ou un modèle nul plus complexe. Même pour les modèles nuls les plus simples, nous connaissons rarement la distribution théorique pour une statistique sommaire du patron de points sous le modèle nul. Les tests d’hypothèses sur les patrons de points sont donc réalisés par simulation: on simule un grand nombre de patrons de points à partir du modèle nul et on compare la distribution des statistiques sommaires qui nous intéressent pour ces simulations à la valeur des statistiques pour le patron de points observé.</p>
</div>
<div id="indice-k-de-ripley" class="section level2">
<h2>Indice <span class="math inline">\(K\)</span> de Ripley</h2>
<p>L’indice de Ripley <span class="math inline">\(K(r)\)</span> est défini comme le nombre moyen de points se trouvant dans un cercle de rayon <span class="math inline">\(r\)</span> donné autour d’un point du patron, normalisé par l’intensité <span class="math inline">\(\lambda\)</span>.</p>
<p>Pour un patron totalement aléatoire, le nombre moyen de points dans un cercle de rayon <span class="math inline">\(r\)</span> est <span class="math inline">\(\lambda \pi r^2\)</span>, donc en théorie <span class="math inline">\(K(r) = \pi r^2\)</span> pour ce modèle nul. Une valeur de <span class="math inline">\(K(r)\)</span> supérieure signifie qu’il y a agrégation des points à l’échelle <span class="math inline">\(r\)</span>, tandis qu’une valeur inférieure signifie qu’il y a une répulsion.</p>
<p>En pratique, <span class="math inline">\(K(r)\)</span> est estimé pour un patron de points donné par l’équation:</p>
<p><span class="math display">\[ K(r) = \frac{A}{n(n-1)} \sum_i \sum_{j &gt; i} I \left( d_{ij} \le r \right) w_{ij}\]</span></p>
<p>où <span class="math inline">\(A\)</span> est l’aire de la fenêtre d’observation et <span class="math inline">\(n\)</span> est le nombre de points du patron, donc <span class="math inline">\(n(n-1)\)</span> est le nombre de paires de points distinctes. On fait la somme pour toutes les paires de points de la fonction indicatrice <span class="math inline">\(I\)</span>, qui prend une valeur de 1 si la distance entre les points <span class="math inline">\(i\)</span> et <span class="math inline">\(j\)</span> est inférieure ou égale à <span class="math inline">\(r\)</span>. Finalement, le terme <span class="math inline">\(w_{ij}\)</span> permet de donner un poids supplémentaire à certaines paires de points pour tenir compte des effets de bordure, tel que discuté dans la section suivante.</p>
<p>Par exemple, les graphiques ci-dessous présentent la fonction estimée <span class="math inline">\(K(r)\)</span> pour les patrons illustrés ci-dessus, pour des valeurs de <span class="math inline">\(r\)</span> allant jusqu’à 1/4 de la largeur de la fenêtre. La courbe pointillée rouge indique la valeur théorique pour une structure spatiale totalement aléatoire et la zone grise est une “enveloppe” produite par 99 simulations de ce modèle nul. Le patron agrégé montre un excès de voisins jusqu’à <span class="math inline">\(r = 0.25\)</span> et le patron avec répulsion montre un déficit significatif de voisins pour les petites valeurs de <span class="math inline">\(r\)</span>.</p>
<p><img src="1-Patrons_points_files/figure-html/unnamed-chunk-4-1.png" width="864" /></p>
<p>Outre le <span class="math inline">\(K\)</span>, il existe d’autres statistiques pour décrire les propriétés de second ordre du patron, par exemple la distance moyenne entre un point et ses <span class="math inline">\(N\)</span> plus proches voisins. Vous pouvez consulter le manuel de Wiegand et Moloney (2013) suggéré en référence pour en apprendre plus sur différentes statistiques sommaires des patrons de points.</p>
</div>
<div id="effets-de-bordure" class="section level2">
<h2>Effets de bordure</h2>
<p>Dans le contexte de l’analyse de patrons de points, l’effet de bordure (“edge effect”) est dû au fait que nous avons une connaissance incomplète du voisinage des points près du bord de la fenêtre d’observation, ce qui peut induire un biais dans le calcul des statistiques comme le <span class="math inline">\(K\)</span> de Ripley.</p>
<p>Différentes méthodes ont été développées pour corriger le biais dû aux effets de bordure. Selon la méthode de Ripley, la contribution d’un voisin <span class="math inline">\(j\)</span> situé à une distance <span class="math inline">\(r\)</span> d’un point <span class="math inline">\(i\)</span> reçoit un poids <span class="math inline">\(w_{ij} = 1/\phi_i(r)\)</span>, où <span class="math inline">\(\phi_i(r)\)</span> est la fraction du cercle de rayon <span class="math inline">\(r\)</span> autour de <span class="math inline">\(i\)</span> contenu dans la fenêtre d’observation. Par exemple, si 2/3 du cercle se trouve dans la fenêtre, ce voisin compte pour 3/2 voisins dans le calcul d’une statistique comme <span class="math inline">\(K\)</span>.</p>
<p><img src="images/ripley_edge.png" /></p>
<p>La méthode de Ripley est une des plus simples pour corriger les effets de bordure, mais n’est pas nécessairement la plus efficace; notamment, les poids plus grands donnés à certaines paires de points tend à accroître la variance du calcul de la statistique. D’autres méthodes de correction sont présentées dans les manuels spécialisés, comme celui de Wiegand et Moloney (2013) en référence.</p>
</div>
<div id="exemple" class="section level2">
<h2>Exemple</h2>
<p>Pour cet exemple, nous utilisons le jeu de données <a href="data/semis_xy.csv">semis_xy.csv</a>, qui représente les coordonnées <span class="math inline">\((x, y)\)</span> de semis de deux espèces (<em>sp</em>, B = bouleau et P = peuplier) dans une placette de 15 x 15 m.</p>
<pre class="r"><code>semis &lt;- read.csv(&quot;data/semis_xy.csv&quot;)
head(semis)</code></pre>
<pre><code>##       x    y sp
## 1 14.73 0.05  P
## 2 14.72 1.71  P
## 3 14.31 2.06  P
## 4 14.16 2.64  P
## 5 14.12 4.15  B
## 6  9.88 4.08  B</code></pre>
<p>Le package <em>spatstat</em> permet d’effectuer des analyses de patrons de point dans R. La première étape consiste à transformer notre tableau de données en objet <code>ppp</code> (patron de points) avec la fonction du même nom. Dans cette fonction, nous spécifions quelles colonnes contiennent les coordonnées <em>x</em> et <em>y</em> ainsi que les marques (<code>marks</code>), qui seront ici les codes d’espèce. Il faut aussi spécifier une fenêtre d’observation (<code>window</code>) à l’aide de la fonction <code>owin</code>, à laquelle nous indiquons les limites de la placette en <em>x</em> et <em>y</em>.</p>
<pre class="r"><code>library(spatstat)

semis &lt;- ppp(x = semis$x, y = semis$y, marks = as.factor(semis$sp),
             window = owin(xrange = c(0, 15), yrange = c(0, 15)))
semis</code></pre>
<pre><code>## Marked planar point pattern: 281 points
## Multitype, with levels = B, P 
## window: rectangle = [0, 15] x [0, 15] units</code></pre>
<p>Les marques peuvent être numériques ou catégorielles. Notez que pour des marques catégorielles comme c’est le cas ici, il faut convertir explicitement la variable en facteur.</p>
<p>La fonction <code>plot</code> appliquée à un patron de points montre un diagramme du patron.</p>
<pre class="r"><code>plot(semis)</code></pre>
<p><img src="1-Patrons_points_files/figure-html/unnamed-chunk-7-1.png" width="672" /></p>
<p>La fonction <code>intensity</code> calcule la densité des points de chaque espèce par unité de surface, ici en <span class="math inline">\(m^2\)</span>.</p>
<pre class="r"><code>intensity(semis)</code></pre>
<pre><code>##         B         P 
## 0.6666667 0.5822222</code></pre>
<p>Pour analyser d’abord séparément la distribution de chaque espèce, nous séparons le patron avec <code>split</code>. Puisque le patron contient des marques catégorielles, la séparation se fait automatiquement en fonction de la valeur des marques. Le résultat est une liste de deux patrons de points.</p>
<pre class="r"><code>semis_split &lt;- split(semis)
plot(semis_split)</code></pre>
<p><img src="1-Patrons_points_files/figure-html/unnamed-chunk-9-1.png" width="672" /></p>
<p>La fonction <code>Kest</code> calcule le <span class="math inline">\(K\)</span> de Ripley pour une série de distances allant (par défaut) jusqu’à 1/4 de la largeur de la fenêtre. Ici, nous l’appliquons au premier patron (bouleau) en choisissant <code>semis_split[[1]]</code>. Notez que les doubles crochets sont nécessaires pour choisir un élément d’une liste dans R.</p>
<p>L’argument <code>correction = "iso"</code> indique d’appliquer la méthode de Ripley pour corriger les effets de bordure.</p>
<pre class="r"><code>k &lt;- Kest(semis_split[[1]], correction = &quot;iso&quot;)
plot(k)</code></pre>
<p><img src="1-Patrons_points_files/figure-html/unnamed-chunk-10-1.png" width="672" /></p>
<p>Selon ce graphique, il semble y avoir une excès de voisins à partir d’un rayon de 1 m. Pour vérifier s’il s’agit d’un écart significatif, nous produisons une enveloppe de simulation avec la fonction <code>envelope</code>. Le permier argument d’<code>envelope</code> est un patron de point auquel les simulations seront comparées, le deuxième une fonction à calculer (ici, <code>Kest</code>) pour chaque patron simulé, puis on y ajoute les arguments de la fonction <code>Kest</code> (ici, seulement <code>correction</code>).</p>
<pre class="r"><code>plot(envelope(semis_split[[1]], Kest, correction = &quot;iso&quot;))</code></pre>
<pre><code>## Generating 99 simulations of CSR  ...
## 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40,
## 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80,
## 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98,  99.
## 
## Done.</code></pre>
<p><img src="1-Patrons_points_files/figure-html/unnamed-chunk-11-1.png" width="672" /></p>
<p>Tel qu’indiqué par le message, cette fonction effectue par défaut 99 simulations de l’hypothèse nulle correspondant à une structure spatiale totalement aléatoire (CSR, pour <em>complete spatial randomness</em>).</p>
<p>La courbe observée sort de l’enveloppe des 99 simulations près de <span class="math inline">\(r = 2\)</span>. Il faut être prudent de ne pas interpréter trop rapidement un résultat sortant de l’enveloppe. Même s’il y a environ une probabilité de 1% d’obtenir un résultat plus extrême selon l’hypothèse nulle à une distance donnée, l’enveloppe est calculée pour un grand nombre de valeurs de la distance et nous n’effectuons pas de correction pour les comparaisons multiples. Ainsi, un écart significatif pour une très petite plage de valeurs de <span class="math inline">\(r\)</span> peut être simplement dû au hasard.</p>
<div id="exercice-1" class="section level3">
<h3>Exercice 1</h3>
<p>En regardant le graphique du deuxième patron de points (semis de peuplier), pouvez-vous prédire où se situera le <span class="math inline">\(K\)</span> de Ripley par rapport à l’hypothèse nulle d’une structure spatiale totalement aléatoire? Vérifiez votre prédiction en calculant le <span class="math inline">\(K\)</span> de Ripley pour ce patron de points dans R.</p>
</div>
</div>
<div id="effet-de-lhétérogénéité" class="section level2">
<h2>Effet de l’hétérogénéité</h2>
<p>Le graphique ci-dessous illustre un patron de points <em>hétérogène</em>, c’est-à-dire qu’il présente un gradient d’intensité (plus de points à gauche qu’à droite).</p>
<p><img src="1-Patrons_points_files/figure-html/unnamed-chunk-13-1.png" width="672" /></p>
<p>Un gradient de densité peut être confondu avec une agrégation des points, comme on peut voir sur le graphique du <span class="math inline">\(K\)</span> de Ripley correspondant. En théorie, il s’agit de deux processus différents:</p>
<ul>
<li><p>Hétérogénéité: La densité de points varie dans la région d’étude, par exemple dû au fait que certaines conditions locales sont plus propices à la présence de l’espèce étudiée.</p></li>
<li><p>Agrégation: La densité moyenne des points est homogène, mais la présence d’un point augmente la présence d’autre points dans son voisinage, par exemple en raison d’interactions positives entre les individus.</p></li>
</ul>
<p>Cependant, il peut être difficile de différencier les deux en pratique, surtout que certains patrons peuvent être à la fois hétérogènes et agrégés.</p>
<p>Prenons l’exemple des semis de peuplier de l’exercice précédent. La fonction <code>density</code> appliquée à un patron de points effectue une estimation par noyau (<em>kernel density estimation</em>) de la densité des semis à travers la placette. Par défaut, cette fonction utilise un noyau gaussien avec un écart-type <code>sigma</code> spécifié dans la fonction, qui détermine l’échelle à laquelle les fluctuations de densité sont “lissées”. Ici, nous utilisons une valeur de 2 m pour <code>sigma</code> et nous représentons d’abord la densité estimée avec <code>plot</code>, avant d’y superposer les points (<code>add = TRUE</code> signifie que les points sont ajoutés au graphique existant plutôt que de créer un nouveau graphique).</p>
<pre class="r"><code>dens_p &lt;- density(semis_split[[2]], sigma = 2)
plot(dens_p)
plot(semis_split[[2]], add = TRUE)</code></pre>
<p><img src="1-Patrons_points_files/figure-html/unnamed-chunk-14-1.png" width="672" /></p>
<p>Pour mesurer l’agrégation ou la répulsion des points d’un patron hétérogène, nous devons utilisé la version non-homogène de la statistique <span class="math inline">\(K\)</span> (<code>Kinhom</code> dans <em>spatstat</em>). Cette statistique est toujours égale au nombre moyen de voisins dans un rayon <span class="math inline">\(r\)</span> d’un point du patron, mais plutôt que de normaliser ce nombre par l’intensité globale du patron, il est normalisé par l’estimation locale de la densité de points. Pour spécifier cette densité variable, nous assignons <code>dens_p</code> à l’argument <code>lambda</code> dans <code>Kinhom</code>.</p>
<pre class="r"><code>plot(Kinhom(semis_split[[2]], lambda = dens_p, correction = &quot;iso&quot;))</code></pre>
<p><img src="1-Patrons_points_files/figure-html/unnamed-chunk-15-1.png" width="672" /></p>
<p>En tenant compte de l’hétérogénéité du patron à une échelle <code>sigma</code> de 2 m, il semble donc y avoir un déficit de voisins à partir d’environ 1.5 m des points du patron. Il reste à voir si cette déviation est significative.</p>
<p>Comme précédemment, nous utilisons <code>envelope</code> pour simuler la statistique <code>Kinhom</code> sous le modèle nul. Cependant, ici le modèle nul n’est pas un processus de Poisson homogène (structure spatiale totalement aléatoire). Il s’agit plutôt d’un processus de Poisson hétérogène simulé par la fonction <code>rpoispp(dens_p)</code>, c’est-à-dire que les points sont indépendants les uns des autres, mais leur densité est hétérogène et donnée par <code>dens_p</code>. L’argument <code>simulate</code> de la fonction <code>envelope</code> permet de spécifier une fonction utilisée pour les simulations sous le modèle nul; cette fonction doit avoir un argument, ici <code>x</code>, même s’il n’est pas utilisé.</p>
<p>Finalement, en plus des arguments nécessaires pour <code>Kinhom</code>, soit <code>lambda</code> et <code>correction</code>, nous spécifions aussi <code>nsim = 199</code> pour réaliser 199 simulations et <code>nrank = 5</code> pour éliminer les 5 résultats les plus extrêmes de chaque côté de l’enveloppe, donc les 10 plus extrêmes sur 199, pour réaliser un intervalle contenant environ 95% de la probabilité sous l’hypothèse nulle.</p>
<pre class="r"><code>khet_p &lt;- envelope(semis_split[[2]], Kinhom, lambda = dens_p,  correction = &quot;iso&quot;,
                   nsim = 199, nrank = 5, simulate = function(x) rpoispp(dens_p))</code></pre>
<pre><code>## Warning: Envelope may be invalid; argument &#39;lambda&#39; appears to have been fixed.</code></pre>
<pre><code>## Generating 199 simulations by evaluating function  ...
## 1, 2, 3, 4.6.8.10.12.14.16.18.20.22.24.26.28.30.32.34.36.38.40
## .42.44.46.48.50.52.54.56.58.60.62.64.66.68.70.72.74.76.78.80
## .82.84.86.88.90.92.94.96.98.100.102.104.106.108.110.112.114.116.118.120
## .122.124.126.128.130.132.134.136.138.140.142.144.146.148.150.152.154.156.158.160
## .162.164.166.168.170.172.174.176.178.180.182.184.186.188.190.192.194.196.198 199.
## 
## Done.</code></pre>
<pre class="r"><code>plot(khet_p)</code></pre>
<p><img src="1-Patrons_points_files/figure-html/unnamed-chunk-16-1.png" width="672" /></p>
<p><em>Note</em>: Pour un test d’hypothèse basé sur des simulations d’une hypothèse nulle, la valeur <span class="math inline">\(p\)</span> est estimée par <span class="math inline">\((m + 1)/(n + 1)\)</span>, où <span class="math inline">\(n\)</span> est le nombre de simulations et <span class="math inline">\(m\)</span> est le nombre de simulations où la valeur de la statistique est plus extrême que celle des données observées. C’est pour cette raison qu’on choisit un nombre de simulations comme 99, 199, etc.</p>
<div id="exercice-2" class="section level3">
<h3>Exercice 2</h3>
<p>Répétez l’estimation de la densité hétérogène et le calcul de <code>Kinhom</code> avec un écart-type <code>sigma</code> de 5 plutôt que 2. Comment le niveau de lissage pour la densité influence-t-il les conclusions?</p>
<p>Pour différencier une variation de densité des points et d’une interaction (agrégation ou répulsion) entre ces points avec ce type d’analyse, il faut généralement supposer que les deux processus opèrent à différentes échelles. Typiquement, nous pouvons tester si les points sont agrégés à petite échelle après avoir tenu compte d’une variation de la densité à une échelle plus grande.</p>
</div>
</div>
<div id="relation-entre-deux-patrons-de-points" class="section level2">
<h2>Relation entre deux patrons de points</h2>
<p>Considérons un cas où nous avons deux patrons de points, par exemple la position des arbres de deux espèces dans une parcelle (points oranges et verts dans le graphique ci-dessous). Chacun des deux patrons peut présenter ou non des agrégations de points.</p>
<p><img src="1-Patrons_points_files/figure-html/unnamed-chunk-17-1.png" width="672" /></p>
<p>Sans égard à cette agrégation au niveau de l’espèce, nous voulons déterminer si les deux espèces sont disposées indépendamment. Autrement dit, la probabilité d’observer un arbre d’une espèce dépend-elle de la présence d’un arbre de l’autre espèce à une distance donnée?</p>
<p>La version bivariée du <span class="math inline">\(K\)</span> de Ripley permet de répondre à cette question. Pour deux patrons désignés 1 et 2, l’indice <span class="math inline">\(K_{12}(r)\)</span> calcule le nombre moyen de points du patron 2 dans un rayon <span class="math inline">\(r\)</span> autour d’un point du patron 1, normalisé par la densité du patron 2.</p>
<p>En théorie, cet indice est symétrique, donc <span class="math inline">\(K_{12}(r) = K_{21}(r)\)</span> et le résultat serait le même si on choisit les points du patron 1 ou 2 comme points “focaux” pour l’analyse. Cependant, l’estimation des deux quantités pour un patron observé peut différer, notamment en raison des effets de bord. La variabilité peut aussi être différente pour <span class="math inline">\(K_{12}\)</span> et <span class="math inline">\(K_{21}\)</span> entre les simulations d’un modèle nul, donc le test de l’hypothèse nulle peut avoir une puissance différente selon le choix de l’espèce focale.</p>
<p>Le choix d’un modèle nul approprié est important ici. Afin de déterminer s’il existe une attraction ou une répulsion significative entre les deux patrons, il faut déplacer aléatoirement la position d’un des patrons relative à celle de l’autre patron, tout en conservant la structure spatiale de chaque patron pris isolément.</p>
<p>Une des façons d’effectuer cette randomisation consiste à décaler l’un des deux patrons horizontalement et/ou verticalement d’une distance aléatoire. La partie du patron qui “sort” d’un côté de la fenêtre est rattachée de l’autre côté. Cette méthode s’appelle une translation toroïdale (<em>toroidal shift</em>), car en connectant le haut et le bas ainsi que la gauche et la droite d’une surface rectangulaire, on obtient la forme d’un tore (un “beigne” en trois dimensions).</p>
<p><img src="1-Patrons_points_files/figure-html/unnamed-chunk-18-1.png" width="672" /></p>
<p>Le graphique ci-dessus illustre une translation du patron vert vers la droite, tandis que le patron orange reste au même endroit. Les points verts dans la zone ombragée sont ramenés de l’autre côté. Notez que si cette méthode préserve de façon générale la structure de chaque patron tout en randomisant leur position relative, elle peut comporter certains inconvénients, comme de diviser des amas de points qui se trouvent près du point de coupure.</p>
<p>Vérifions maintenant s’il y a une dépendance entre la position des deux espèces (bouleau et peuplier) dans notre placette. La fonction <code>Kcross</code> calcule l’indice bivarié <span class="math inline">\(K_{ij}\)</span>, il faut spécifier quel type de point est considéré comme l’espèce focale <span class="math inline">\(i\)</span> et l’espèce voisine <span class="math inline">\(j\)</span>.</p>
<pre class="r"><code>plot(Kcross(semis, i = &quot;P&quot;, j = &quot;B&quot;, correction = &quot;iso&quot;))</code></pre>
<p><img src="1-Patrons_points_files/figure-html/unnamed-chunk-19-1.png" width="672" /></p>
<p>Ici, le <span class="math inline">\(K\)</span> observé est inférieur à la valeur théorique, indiquant une répulsion possible des deux patrons.</p>
<p>Pour déterminer l’enveloppe du <span class="math inline">\(K\)</span> selon l’hypothèse nulle d’indépendance des deux patrons, nous devons spécifier que les simulations doivent être basées sur une translation des patrons. Nous indiquons que les simulations doivent utiliser la fonction <code>rshift</code> (translation aléatoire) avec l’argument <code>simulate = function(x) rshift(x, which = "B")</code>; ici, l’argument <code>x</code> de <code>simulate</code> correspond au patron de points original et l’argument <code>which</code> indique quel type de points subit la translation. Comme pour le cas précédent, il faut répéter dans la fonction <code>envelope</code> les arguments nécessaires pour <code>Kcross</code>, soit <code>i</code>, <code>j</code> et <code>correction</code>.</p>
<pre class="r"><code>plot(envelope(semis, Kcross, i = &quot;P&quot;, j = &quot;B&quot;, correction = &quot;iso&quot;, 
              nsim = 199, nrank = 5, simulate = function(x) rshift(x, which = &quot;B&quot;)))</code></pre>
<pre><code>## Generating 199 simulations by evaluating function  ...
## 1, 2, 3, 4.6.8.10.12.14.16.18.20.22.24.26.28.30.32.34.36.38.40
## .42.44.46.48.50.52.54.56.58.60.62.64.66.68.70.72.74.76.78.80
## .82.84.86.88.90.92.94.96.98.100.102.104.106.108.110.112.114.116.118.120
## .122.124.126.128.130.132.134.136.138.140.142.144.146.148.150.152.154.156.158.160
## .162.164.166.168.170.172.174.176.178.180.182.184.186.188.190.192.194.196.198 199.
## 
## Done.</code></pre>
<p><img src="1-Patrons_points_files/figure-html/unnamed-chunk-20-1.png" width="672" /></p>
<p>Ici, la courbe observée se situe totalement dans l’enveloppe, donc nous ne rejetons pas l’hypothèse nulle d’indépendance des deux patrons.</p>
<div id="questions" class="section level3">
<h3>Questions</h3>
<ol style="list-style-type: decimal">
<li><p>Quelle raison pourrait justifier ici notre choix d’effectuer la translation des points du bouleau plutôt que du peuplier?</p></li>
<li><p>Est-ce que les simulations générées par translation aléatoire constitueraient un bon modèle nul si les deux patrons étaient hétérogènes?</p></li>
</ol>
</div>
</div>
<div id="patrons-de-points-marqués" class="section level2">
<h2>Patrons de points marqués</h2>
<p>Le jeu de données <a href="data/fir.csv">fir.csv</a> contient les coordonnées <span class="math inline">\((x, y)\)</span> de 822 sapins dans une placette d’un hectare et leur statut (A = vivant, D = mort) suivant une épidémie de tordeuse des bourgeons de l’épinette.</p>
<pre class="r"><code>fir &lt;- read.csv(&quot;data/fir.csv&quot;)
head(fir)</code></pre>
<pre><code>##       x     y status
## 1 31.50  1.00      A
## 2 85.25 30.75      D
## 3 83.50 38.50      A
## 4 84.00 37.75      A
## 5 83.00 33.25      A
## 6 33.25  0.25      A</code></pre>
<pre class="r"><code>fir &lt;- ppp(x = fir$x, y = fir$y, marks = as.factor(fir$status),
           window = owin(xrange = c(0, 100), yrange = c(0, 100)))
plot(fir)</code></pre>
<p><img src="1-Patrons_points_files/figure-html/unnamed-chunk-22-1.png" width="672" /></p>
<p>Supposons que nous voulons vérifier si la mortalité des sapins est indépendante ou corrélée entre arbres rapprochés. En quoi cette question diffère-t-elle de l’exemple précédent où nous voulions savoir si la position des points de deux espèces était indépendante?</p>
<p>Dans l’exemple précédent, l’indépendance ou l’interaction entre les espèces référait à la formation du patron lui-même (que des semis d’une espèce s’établissent ou non à proximité de ceux de l’autre espèce). Ici, la caractéristique qui nous intéresse (survie des sapins) est postérieure à l’établissement du patron, en supposant que tous ces arbres étaient vivants d’abord et que certains sont morts suite à l’épidémie. Donc nous prenons la position des arbres comme fixe et nous voulons savoir si la distribution des statuts (mort, vivant) entre ces arbres est aléatoire ou présente un patron spatial.</p>
<p>Dans le manuel de Wiegand et Moloney, la première situation (établissement de semis de deux espèces) est appelé patron bivarié, donc il s’agit vraiment de deux patrons qui interagissent, tandis que la deuxième est un seul patron avec une <em>marque</em> qualitative. Le package <em>spatstat</em> dans R ne fait pas de différences entre les deux au niveau de la définition du patron (les types de points sont toujours représentés par l’argument <code>marks</code>), mais les méthodes d’analyse appliquées aux deux questions diffèrent.</p>
<p>Dans le cas d’un patron avec une marque qualitative, nous pouvons définir une fonction de connexion de marques (<em>mark connection function</em>) <span class="math inline">\(p_{ij}(r)\)</span>. Pour deux points séparés par une distance <span class="math inline">\(r\)</span>, cette fonction donne la probabilité que le premier point porte la marque <span class="math inline">\(i\)</span> et le deuxième la marque <span class="math inline">\(j\)</span>. Selon l’hypothèse nulle où les marques sont indépendantes, cette probabilité est égale au produit des proportions de chaque marque dans le patron entier, <span class="math inline">\(p_{ij}(r) = p_i p_j\)</span> indépendamment de <span class="math inline">\(r\)</span>.</p>
<p>Dans <em>spatstat</em>, la fonction de connexion de marques est calculée avec la fonction <code>markconnect</code>, où il faut spécifier les marques <span class="math inline">\(i\)</span> et <span class="math inline">\(j\)</span> ainsi que le type de correction des effets de bord. Dans notre exemple, nous voyons que deux points rapprochés ont moins de chance d’avoir une statut différent (A et D) que prévu selon l’hypothèse de distribution aléatoire et indépendante des marques (ligne rouge pointillée).</p>
<pre class="r"><code>plot(markconnect(fir, i = &quot;A&quot;, j = &quot;D&quot;, correction = &quot;iso&quot;))</code></pre>
<p><img src="1-Patrons_points_files/figure-html/unnamed-chunk-23-1.png" width="672" /></p>
<p>Dans ce graphique, les ondulations dans la fonction sont dues à l’erreur d’estimation d’une fonction continue de <span class="math inline">\(r\)</span> à partir d’un nombre limité de paires de points discrètes.</p>
<p>Pour simuler le modèle nul dans ce cas-ci, nous utilisons la fonction <code>rlabel</code> qui réassigne aléatoirement les marques parmi les points du patron, en maintenant la position des points.</p>
<pre class="r"><code>plot(envelope(fir, markconnect, i = &quot;A&quot;, j = &quot;D&quot;, correction = &quot;iso&quot;, 
              nsim = 199, nrank = 5, simulate = rlabel))</code></pre>
<pre><code>## Generating 199 simulations by evaluating function  ...
## 1, 2, 3, 4.6.8.10.12.14.16.18.20.22.24.26.28.30.32.34.36.38.40
## .42.44.46.48.50.52.54.56.58.60.62.64.66.68.70.72.74.76.78.80
## .82.84.86.88.90.92.94.96.98.100.102.104.106.108.110.112.114.116.118.120
## .122.124.126.128.130.132.134.136.138.140.142.144.146.148.150.152.154.156.158.160
## .162.164.166.168.170.172.174.176.178.180.182.184.186.188.190.192.194.196.198 199.
## 
## Done.</code></pre>
<p><img src="1-Patrons_points_files/figure-html/unnamed-chunk-24-1.png" width="672" /></p>
<p>Notez que puisque la fonction <code>rlabel</code> a un seul argument obligatoire correspondant au patron de points original, il n’était pas nécessaire de spécifier au long: <code>simulate = function(x) rlabel(x)</code>.</p>
<p>Voici les résultats pour les paires d’arbres du même statut A ou D:</p>
<pre class="r"><code>par(mfrow = c(1, 2))
plot(envelope(fir, markconnect, i = &quot;A&quot;, j = &quot;A&quot;, correction = &quot;iso&quot;, 
              nsim = 199, nrank = 5, simulate = rlabel))</code></pre>
<pre><code>## Generating 199 simulations by evaluating function  ...
## 1, 2, 3, 4.6.8.10.12.14.16.18.20.22.24.26.28.30.32.34.36.38.40
## .42.44.46.48.50.52.54.56.58.60.62.64.66.68.70.72.74.76.78.80
## .82.84.86.88.90.92.94.96.98.100.102.104.106.108.110.112.114.116.118.120
## .122.124.126.128.130.132.134.136.138.140.142.144.146.148.150.152.154.156.158.160
## .162.164.166.168.170.172.174.176.178.180.182.184.186.188.190.192.194.196.198 199.
## 
## Done.</code></pre>
<pre class="r"><code>plot(envelope(fir, markconnect, i = &quot;D&quot;, j = &quot;D&quot;, correction = &quot;iso&quot;, 
              nsim = 199, nrank = 5, simulate = rlabel))</code></pre>
<pre><code>## Generating 199 simulations by evaluating function  ...
## 1, 2, 3, 4.6.8.10.12.14.16.18.20.22.24.26.28.30.32.34.36.38.40
## .42.44.46.48.50.52.54.56.58.60.62.64.66.68.70.72.74.76.78.80
## .82.84.86.88.90.92.94.96.98.100.102.104.106.108.110.112.114.116.118.120
## .122.124.126.128.130.132.134.136.138.140.142.144.146.148.150.152.154.156.158.160
## .162.164.166.168.170.172.174.176.178.180.182.184.186.188.190.192.194.196.198 199.
## 
## Done.</code></pre>
<p><img src="1-Patrons_points_files/figure-html/unnamed-chunk-25-1.png" width="960" /></p>
<p>Il semble donc que la mortalité des sapins due à cette épidémie est agrégée spatialement, puisque les arbres situés à proximité l’un de l’autre ont une plus grande probabilité de partager le même statut que prévu par l’hypothèse nulle.</p>
</div>
<div id="références" class="section level2">
<h2>Références</h2>
<p>Fortin, M.-J. et Dale, M.R.T. (2005) <em>Spatial Analysis: A Guide for Ecologists</em>. Cambridge University Press: Cambridge, UK.</p>
<p>Wiegand, T. et Moloney, K.A. (2013) <em>Handbook of Spatial Point-Pattern Analysis in Ecology</em>, CRC Press.</p>
<p>Le jeu de données du dernier exemple est tiré des données de la Forêt d’enseignement et de recherche du Lac Duparquet (FERLD), disponibles sur Dryad en suivant <a href="https://doi.org/10.5061/dryad.tqjq2bvwz">ce lien</a>.</p>
</div>
</div>
<div id="solutions" class="section level1">
<h1>Solutions</h1>
<div id="exercice-1-1" class="section level3">
<h3>Exercice 1</h3>
<pre class="r"><code>plot(envelope(semis_split[[2]], Kest, correction = &quot;iso&quot;))</code></pre>
<pre><code>## Generating 99 simulations of CSR  ...
## 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40,
## 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80,
## 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98,  99.
## 
## Done.</code></pre>
<p><img src="1-Patrons_points_files/figure-html/unnamed-chunk-26-1.png" width="672" /></p>
<p>Les semis de peuplier semblent significativement agrégés selon la valeur du <span class="math inline">\(K\)</span>.</p>
</div>
<div id="exercice-2-1" class="section level3">
<h3>Exercice 2</h3>
<pre class="r"><code>dens_p &lt;- density(semis_split[[2]], sigma = 5)
plot(dens_p)
plot(semis_split[[2]], add = TRUE)</code></pre>
<p><img src="1-Patrons_points_files/figure-html/unnamed-chunk-27-1.png" width="672" /></p>
<pre class="r"><code>khet_p &lt;- envelope(semis_split[[2]], Kinhom, lambda = dens_p,  correction = &quot;iso&quot;,
                   nsim = 199, nrank = 5, simulate = function(x) rpoispp(dens_p))</code></pre>
<pre><code>## Warning: Envelope may be invalid; argument &#39;lambda&#39; appears to have been fixed.</code></pre>
<pre><code>## Generating 199 simulations by evaluating function  ...
## 1, 2, 3, 4.6.8.10.12.14.16.18.20.22.24.26.28.30.32.34.36.38.40
## .42.44.46.48.50.52.54.56.58.60.62.64.66.68.70.72.74.76.78.80
## .82.84.86.88.90.92.94.96.98.100.102.104.106.108.110.112.114.116.118.120
## .122.124.126.128.130.132.134.136.138.140.142.144.146.148.150.152.154.156.158.160
## .162.164.166.168.170.172.174.176.178.180.182.184.186.188.190.192.194.196.198 199.
## 
## Done.</code></pre>
<pre class="r"><code>plot(khet_p)</code></pre>
<p><img src="1-Patrons_points_files/figure-html/unnamed-chunk-27-2.png" width="672" /></p>
<p>Ici, puisque nous estimons la variation de densité à une plus grande échelle, même après avoir tenu compte de cette variation, les semis de peuplier semblent agrégés à petite échelle.</p>
</div>
</div>



</div>
</div>

</div>

<script>

// add bootstrap table styles to pandoc tables
function bootstrapStylePandocTables() {
  $('tr.header').parent('thead').parent('table').addClass('table table-condensed');
}
$(document).ready(function () {
  bootstrapStylePandocTables();
});


</script>

<!-- tabsets -->

<script>
$(document).ready(function () {
  window.buildTabsets("TOC");
});

$(document).ready(function () {
  $('.tabset-dropdown > .nav-tabs > li').click(function () {
    $(this).parent().toggleClass('nav-tabs-open')
  });
});
</script>

<!-- code folding -->

<script>
$(document).ready(function ()  {

    // move toc-ignore selectors from section div to header
    $('div.section.toc-ignore')
        .removeClass('toc-ignore')
        .children('h1,h2,h3,h4,h5').addClass('toc-ignore');

    // establish options
    var options = {
      selectors: "h1,h2,h3",
      theme: "bootstrap3",
      context: '.toc-content',
      hashGenerator: function (text) {
        return text.replace(/[.\\/?&!#<>]/g, '').replace(/\s/g, '_').toLowerCase();
      },
      ignoreSelector: ".toc-ignore",
      scrollTo: 0
    };
    options.showAndHide = true;
    options.smoothScroll = true;

    // tocify
    var toc = $("#TOC").tocify(options).data("toc-tocify");
});
</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
